# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
import discord
from discord.ext import commands, tasks
import aiosqlite
import datetime
import re
import asyncio
import pandas as pd
import os
import logging
import tempfile
import difflib

# -----------------------
# Configuration (env)
# -----------------------
TOKEN = os.environ.get('DISCORD_TOKEN')
REMINDER_CHANNEL_ID = None
try:
    REMINDER_CHANNEL_ID = int(os.environ.get('REMINDER_CHANNEL_ID', '0'))
except Exception:
    REMINDER_CHANNEL_ID = 0
API_KEY = os.environ.get('API_KEY', '')

DB_NAME = os.environ.get('DB_NAME', 'learning_resources.db')
PREFIX = os.environ.get('BOT_PREFIX', '!')

# -----------------------
# Logging
# -----------------------
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s:%(name)s: %(message)s')
logger = logging.getLogger('chinese-bot')

if not TOKEN:
    logger.error("DISCORD_TOKEN not set. Bot will not run.")

# -----------------------
# Intents & bot init
# -----------------------
intents = discord.Intents.default()
intents.message_content = True
intents.members = True

bot = commands.Bot(command_prefix=PREFIX, intents=intents)
bot.db = None
bot.db_lock = asyncio.Lock()  # protect DB writes
# A small in-memory cache to avoid inserting exact duplicates rapidly
bot._recent_urls = set()
bot._recent_urls_lock = asyncio.Lock()

# -----------------------
# URL regex (improved)
# -----------------------
URL_RE = re.compile(r'https?://[^\s<>"]+')

# -----------------------
# Simple FAQ bank
# -----------------------
QA_BANK = {
    "chao ban": "‰Ω†Â•Ω! N«ê h«éo! Ch√†o b·∫°n, b·∫°n c·∫ßn h·ªó tr·ª£ g√¨ v·ªÅ Ti·∫øng Trung ·∫°?",
    "bai tap 5": "B√†i t·∫≠p 5 l√† b√†i HSK 1 v·ªÅ 's·ªë ƒë·∫øm v√† ch√†o h·ªèi'. B·∫°n ƒë√£ l√†m ƒë·∫øn ph·∫ßn luy·ªán nghe ch∆∞a?",
    "tu moi bai 3": "T·ª´ m·ªõi b√†i 3 g·ªìm: ‰Ω†Â•Ω (n«ê h«éo), Ë∞¢Ë∞¢ (xi√®xi√®), ‰∏çÂÆ¢Ê∞î (b√π k√®q√¨).",
    "ngu phap co ban": "Ng·ªØ ph√°p Ti·∫øng Trung c∆° b·∫£n l√† S-V-O. V√≠ d·ª•: Êàë(S) Áà±(V) ‰Ω†(O).",
}

# -----------------------
# Reminders (hour, minute, weekday(0=Mon), message)
# -----------------------
REMINDERS = [
    (19, 30, 2, "üîî ƒê√£ ƒë·∫øn gi·ªù v√†o l·ªõp Ti·∫øng Trung HSK 1! Chu·∫©n b·ªã s√°ch v·ªü v√† tai nghe nh√©."),
    (10, 0, 5, "üìù H√£y d√†nh 30 ph√∫t ƒë·ªÉ √¥n l·∫°i t·ª´ v·ª±ng c≈© v√† l√†m b√†i t·∫≠p ng·ªØ ph√°p tu·∫ßn n√†y.")
]

# -----------------------
# Helpers
# -----------------------
def normalize_url(u: str) -> str:
    # Basic normalizer: strip trailing punctuation and whitespace
    u = u.strip().rstrip('.,;:!?')
    return u

async def ensure_db_initialized():
    if bot.db is None:
        bot.db = await aiosqlite.connect(DB_NAME)
        await bot.db.execute("""
            CREATE TABLE IF NOT EXISTS links (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                url TEXT NOT NULL,
                source TEXT,
                timestamp DATETIME
            )
        """)
        await bot.db.execute("CREATE INDEX IF NOT EXISTS idx_links_url ON links(url)")
        await bot.db.commit()

# -----------------------
# Events
# -----------------------
@bot.event
async def on_ready():
    logger.info("Bot ready: %s", bot.user)
    await ensure_db_initialized()
    if not check_reminders.is_running():
        check_reminders.start()

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.MissingPermissions):
        await ctx.send("B·∫°n kh√¥ng c√≥ quy·ªÅn ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.")
    elif isinstance(error, commands.BadArgument):
        await ctx.send("Tham s·ªë kh√¥ng h·ª£p l·ªá. Ki·ªÉm tra l·∫°i c√∫ ph√°p.")
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send("Thi·∫øu tham s·ªë b·∫Øt bu·ªôc. Ki·ªÉm tra l·∫°i c√∫ ph√°p.")
    else:
        # Log unexpected errors
        logger.exception("Unhandled command error: %s", error)
        await ctx.send(f"C√≥ l·ªói x·∫£y ra: {str(error)}")

@bot.event
async def on_message(message):
    # Ignore self
    if message.author == bot.user:
        return

    # Let commands run first if message starts with prefix
    if message.content.startswith(PREFIX):
        await bot.process_commands(message)
        return

    # Find URLs
    try:
        urls = URL_RE.findall(message.content)
    except Exception:
        urls = []

    if urls:
        normalized = [normalize_url(u) for u in urls]
        # Deduplicate in this message
        unique_urls = list(dict.fromkeys(normalized))
        await ensure_db_initialized()
        async with bot._recent_urls_lock:
            # remove any URLs that were seen in-memory to avoid immediate duplicates
            to_insert = [u for u in unique_urls if u not in bot._recent_urls]
            # keep a sliding window of recent urls
            if to_insert:
                bot._recent_urls.update(to_insert)
                # cap memory cache
                if len(bot._recent_urls) > 2000:
                    # naive reset to prevent unbounded growth
                    bot._recent_urls.clear()
            else:
                to_insert = []

        if to_insert:
            try:
                async with bot.db_lock:
                    async with bot.db.executemany(
                        "INSERT INTO links (url, source, timestamp) VALUES (?, ?, ?)",
                        [(u, f"#{message.channel.name}", datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")) for u in to_insert]
                    ):
                        pass
                    await bot.db.commit()
            except Exception as e:
                logger.exception("Error inserting urls: %s", e)

    await bot.process_commands(message)

# -----------------------
# Commands
# -----------------------
@bot.command(name='tainguyen')
async def get_resources(ctx, limit: int = 10):
    """!tainguyen - Hi·ªÉn th·ªã danh s√°ch c√°c link ƒë∆∞·ª£c g·ª≠i g·∫ßn nh·∫•t."""
    await ensure_db_initialized()
    if limit <= 0 or limit > 50:
        limit = 10
    try:
        async with bot.db.execute("SELECT url, source, timestamp FROM links ORDER BY id DESC LIMIT ?", (limit,)) as cursor:
            rows = await cursor.fetchall()
    except Exception as e:
        logger.exception("DB read failed: %s", e)
        await ctx.send("L·ªói khi ƒë·ªçc DB. Ki·ªÉm tra log.")
        return

    if not rows:
        await ctx.send("Kho t√†i nguy√™n hi·ªán ƒëang tr·ªëng. H√£y g·ª≠i link ƒë·ªÉ bot t·ª± ƒë·ªông l∆∞u nh√©! üíæ")
        return

    embed = discord.Embed(title="üìö Li√™n K·∫øt T√†i Nguy√™n Ti·∫øng Trung G·∫ßn Nh·∫•t", color=0x3498db)
    for i, (url, source, ts) in enumerate(rows, start=1):
        # add as fields to avoid overly long single description
        display_url = url if len(url) <= 75 else url[:72] + "..."
        embed.add_field(name=f"{i}. {source} ‚Ä¢ {ts}", value=f"<{display_url}>", inline=False)

    await ctx.send(embed=embed)

@bot.command(name='hochanh')
async def study_help(ctx, *, question: str):
    """!hochanh <c√¢u h·ªèi> - Tr·∫£ l·ªùi FAQ c∆° b·∫£n (fuzzy match)."""
    q_norm = question.lower().strip()
    # exact first
    if q_norm in QA_BANK:
        await ctx.send(f"**üí° H·ªó tr·ª£ H·ªçc t·∫≠p:** {QA_BANK[q_norm]}")
        return

    # fuzzy match
    choices = list(QA_BANK.keys())
    best = difflib.get_close_matches(q_norm, choices, n=1, cutoff=0.6)
    if best:
        await ctx.send(f"**üí° G·ª£i √Ω:** {QA_BANK[best[0]]} (tr·∫£ l·ªùi cho: {best[0]})")
    else:
        await ctx.send(f"Xin l·ªói, t·ªõ ch∆∞a c√≥ d·ªØ li·ªáu ch√≠nh x√°c cho c√¢u h·ªèi **'{question}'**. B·∫°n c√≥ th·ªÉ d√πng l·ªánh `!hoi` ƒë·ªÉ h·ªèi Tr·ª£ l√Ω AI.")

@bot.command(name='hoi')
async def chat_with_ai(ctx, *, prompt: str):
    """!hoi <c√¢u h·ªèi> - Khung cho API AI (ch∆∞a t√≠ch h·ª£p th·ª±c t·∫ø)."""
    async with ctx.typing():
        if not API_KEY:
            await ctx.send(
                "**[CH·ª®C NƒÇNG AI CHAT CH∆ØA K√çCH HO·∫†T]**\n"
                "ƒê·∫∑t API_KEY trong bi·∫øn m√¥i tr∆∞·ªùng ƒë·ªÉ k√≠ch ho·∫°t. Hi·ªán ch·ªâ c√≥ khung t√≠ch h·ª£p."
            )
            return

        # Example placeholder: integrate provider here (OpenAI, etc.)
        # Example (pseudocode):
        # response = await call_openai(prompt, api_key=API_KEY)
        # await ctx.send(f"**üí¨ Tr·ª£ l√Ω AI:** {response}")
        await ctx.send(f"**üí¨ Tr·ª£ l√Ω AI (ch∆∞a c·∫•u h√¨nh):** ƒê√£ nh·∫≠n c√¢u h·ªèi: '{prompt}'. (API_KEY t·ªìn t·∫°i nh∆∞ng ch∆∞a c√≥ logic g·ªçi AI.)")

@bot.command(name='exportdata')
@commands.has_permissions(administrator=True)
async def export_data(ctx, limit: int = 5000):
    """!exportdata <limit> - Xu·∫•t l·ªãch s·ª≠ tin nh·∫Øn ƒë·ªÉ hu·∫•n luy·ªán AI (ch·ªâ Admin)."""
    if limit <= 0:
        await ctx.send("Limit ph·∫£i l·ªõn h∆°n 0.")
        return

    await ctx.send(f"‚è≥ B·∫Øt ƒë·∫ßu thu th·∫≠p {limit} tin nh·∫Øn g·∫ßn nh·∫•t t·ª´ k√™nh **{ctx.channel.name}**...")
    messages_data = []
    count = 0
    try:
        async for message in ctx.channel.history(limit=limit, oldest_first=False):
            if message.author.bot or (message.content and message.content.startswith(PREFIX)):
                continue
            if message.content:
                messages_data.append({
                    'timestamp': message.created_at.strftime("%Y-%m-%d %H:%M:%S"),
                    'author': message.author.display_name,
                    'content': message.content.replace('\n', ' ')
                })
                count += 1
        if not messages_data:
            await ctx.send("Kh√¥ng t√¨m th·∫•y tin nh·∫Øn h·ª£p l·ªá n√†o ƒë·ªÉ xu·∫•t.")
            return

        df = pd.DataFrame(messages_data)
        # Use a temporary file
        with tempfile.NamedTemporaryFile(prefix=f"chat_{ctx.guild.id}_{ctx.channel.id}_", suffix=".csv", delete=False) as tmp:
            temp_name = tmp.name
        df.to_csv(temp_name, index=False, encoding='utf-8-sig')
        await ctx.send(f"‚úÖ ƒê√£ thu th·∫≠p v√† l∆∞u th√†nh c√¥ng **{count}** tin nh·∫Øn v√†o file.", file=discord.File(temp_name))
    except Exception as e:
        logger.exception("exportdata failed: %s", e)
        await ctx.send(f"L·ªói x·∫£y ra trong qu√° tr√¨nh export: {e}")
    finally:
        try:
            if 'temp_name' in locals() and os.path.exists(temp_name):
                os.remove(temp_name)
        except Exception:
            pass

# -----------------------
# Reminder loop
# -----------------------
@tasks.loop(minutes=1)
async def check_reminders():
    try:
        now = datetime.datetime.utcnow()
        current_hour = now.hour
        current_minute = now.minute
        current_weekday = now.weekday()  # Monday = 0

        channel = bot.get_channel(REMINDER_CHANNEL_ID) if REMINDER_CHANNEL_ID else None
        if channel is None and REMINDER_CHANNEL_ID:
            # try fetch
            try:
                channel = await bot.fetch_channel(REMINDER_CHANNEL_ID)
            except Exception:
                channel = None

        if not channel:
            # channel not configured or not available
            return

        for hour, minute, weekday, content in REMINDERS:
            if current_hour == hour and current_minute == minute and current_weekday == weekday:
                await channel.send(f"**TIN NH·∫ÆN NH·∫ÆC NH·ªû L·ªäCH H·ªåC:** {content} @here")
    except Exception as e:
        logger.exception("Error in check_reminders: %s", e)

# -----------------------
# Shutdown cleanup
# -----------------------
async def close_db():
    try:
        if bot.db:
            await bot.db.close()
            bot.db = None
    except Exception:
        logger.exception("Failed to close DB")

@bot.event
async def on_disconnect():
    await close_db()

# -----------------------
# Run
# -----------------------
if __name__ == '__main__':
    if not TOKEN:
        logger.error("Bot will not start: missing token.")
    else:
        try:
            bot.run(TOKEN)
        except discord.errors.LoginFailure:
            logger.exception("Login failure - check token")
        except Exception:
            logger.exception("Unhandled error while running the bot")
